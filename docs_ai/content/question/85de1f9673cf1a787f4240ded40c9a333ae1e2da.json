{"file_name": "docs/plugins/tutorial/part1.md", "questions": ["What is the life-cycle of a plugin?", "What is the purpose of the __init__() method?", "What is the purpose of the set_up() method?", "What is the purpose of the run() method?", "What is the purpose of the close() method?"], "answer": "## Plugin life-cycle \nPlugins go through a life-cycle in which they are created, executed and recycled.\n\nWorkflow controls this process. When a workflow is created, the system recognizes which classes will be needed to start\nthe process defined in the data flow graph.\n\nThe process is as follows. The workflow checks what class is assigned to the node in the graph and checks if it exists.\nIt then creates its instances by running the parameterless `__init__` method of that class.\n\nIt then checks to see if there is an async set_up method. It passes the plug-in configuration to it. The configuration\nis stored inside the node and is defined during plug-in registration (more on that in a moment). Then the workflow\nexecutes nodes in the graph one by one and runs the `run(self, payload: dict, in_edge=None)` method, passing to it the\nparameters that appeared at the input to the node and the additional information on the connection from the previous\nnode.\n\nWhen the workflow exits, it executes the close method on each node.\n\nIn summary, we have the following methods in the plugin class.\n\n```python\n    __init__()  # (1)\n    async set_up(config)  # (2)\n    async run(input_payload)  # (3)\n    async close()  # (4)\n```\n\n1. Initializes the plugin object\n2. Set-ups the configuration and async resources\n3. Gets the input payload as dictionary and runs the plugin, also returns results on ports\n4. Closes async resources\n\n!!! Info\n    Please click (+) to see the comments for the code"}