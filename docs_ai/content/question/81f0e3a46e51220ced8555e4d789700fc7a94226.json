{"file_name": "docs/plugins/tutorial/part2.md", "questions": ["What validation does the code provide to ensure the user does not enter incorrect values?"], "answer": "## Validation\nNote that although the code works, there may be a situation in which the user in the json editor deletes the initialized\nvalue\n\n```json\n{\n  \"event_type\": \"\"\n}\n```\n\nand puts any other, for example:\n\n```json\n{\n  \"Type\": \"\",\n  \"Position\": 1\n}\n```\n\nThen our code will not work, and we will get `KeyError` when trying to read the value in `self.config['event_type']`.\nSo we need a validation that will not allow the user to enter incorrect values.\n\nFor this we will use the `PluginConfig` object.\n\n```python\nfrom pydantic import validator\nfrom tracardi.service.plugin.domain.config import PluginConfig\n\n\nclass Configuration(PluginConfig):\n    event_type: str  # (1)\n\n    @validator(\"event_type\")  # (2)\n    def must_not_be_empty(cls, value):\n        if len(value) == 0:\n            raise ValueError(\"Event type can not be empty.\")\n        return value\n```\n\n1. Tells that the object has a property named `event_type` and it is of type string. `None` value is not allowed.\n2. `@validator(\"event_type\")` and the method below checks if the value of event_type is not empty.\n\nThe above class defines what our configuration object should look like.\n\n1. `event_type: str` tells that the object has a property named event_type and it is of type string. `None` value is not\n   allowed.\n2. `@validator(\"event_type\")` and the method below checks if the value of event_type is not empty.\n\nLet's use a validator to validate the configuration. For this we need to create a validate function.\n\n```python\ndef validate(config: dict):\n    return Configuration(**config)\n```\n\nAnd we'll use it when setting up `self.config`.\n\n```python\nfrom tracardi.service.plugin.runner import ActionRunner\nfrom tracardi.service.plugin.domain.result import Result\nfrom pydantic import validator\nfrom tracardi.service.plugin.domain.config import PluginConfig\n\n\nclass Configuration(PluginConfig):  # (1)\n    event_type: str\n\n    @validator(\"event_type\")\n    def must_not_be_empty(cls, value):\n        if len(value) == 0:\n            raise ValueError(\"Event type can not be empty.\")\n        return value\n\n\ndef validate(config: dict):  # (2)\n    return Configuration(**config)\n\n\nclass MyPlugin(ActionRunner):\n    config: Configuration  # (3)\n\n    async def set_up(self, config):\n        self.config = validate(config)  # (4)\n\n    async def run(self, payload: dict, in_edge=None):\n        if self.event.type == self.config.event_type:  # (5)\n            return Result(port=\"MyEvent\", value=payload)\n        else:\n            return Result(port=\"NotMyEvent\", value={})\n```\n\n1. Definition of configuration schema. Any data passed to this object will be automatically validated.\n2. Validation function. The name of this function must be `validate`. The system GUI use it internally for validation of\n   any Form and JSON data.\n3. Notice a change in the type of config. Now it is not dict but `Configuration` type\n4. Here we use the validation function when we validate the passed data.\n5. Here we use the Configuration object to compare values.\n\n!!! Info\n    Please click (+) to see the comments for the code\n\nNow it is time to see if the code works.\n\n!!! Info\n    Please check if the code works step by step. You do not have to implement everything to check if the code works.\n    Every time you complete some part of the tutorial you may save the changes and reinstall plugins and see how it\n    works in the workflow editor. Installation of the changed plugin can be done in the workflow editor by clicking\n    the `Reinstall plugins` button."}